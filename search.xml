<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[docker介绍、安装]]></title>
      <url>%2F2017%2F04%2F03%2Fmeet%2F</url>
      <content type="text"><![CDATA[Docker 是一个开源的应用容器引擎，让应用的分发、测试、部署都变得前所未有的高效和轻松！ Ubuntu安装Docker$ curl -fsSL https://get.docker.com/ | sh$ curl -fsSL https://get.docker.com/gpg | sudo apt-key add -sudo systemctl start docker$ sudo service docker startdocker version 查看版本信息 Centos7安装docker1.添加yum repo1 tee /etc/yum.repos.d/docker.repo &lt;&lt;-‘EOF’2 [dockerrepo]3 name=Docker Repository4 baseurl=https://yum.dockerproject.org/repo/main/centos/7/5 enabled=16 gpgcheck=17 gpgkey=https://yum.dockerproject.org/gpg8 EOF 2.安装yum install docker-engine 3.启动systemctl start docker 4.验证docker version 总结此篇文章主要介绍Docker在Ubuntu和Centos7上的安装，当然docker也可在windows和Mac OS上运行，这里就不过多描述了，想了解的小伙伴可以上docker官网学习。 .]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java 编程规范]]></title>
      <url>%2F2017%2F03%2F01%2Fjava-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[为什么要规范代码？代码规范不仅提高了代码的可读性，也避免了一些隐藏bug的出现。好的代码也会让人心情愉悦，提高编程的效率。 编程规约命名规约 常量命名全部大写,单词间用下划线隔开,力求语义表达完整清楚,不要嫌名字长。 正例：MAX_APPLE_COUNT 反例：MAX_COUNT 抽象类命名使用 Abstract 或 Base 开头;异常类命名使用 Exception 结尾;测试类 命名以它要测试的类的名称开始,以 Test 结尾。 中括号是数组类型的一部分,数组推荐定义如下:String[] args; POJO 类中布尔类型的变量,都不要加 is,否则部分框架解析会引起序列化错误。 反例：定义为基本数据类型boolean isSuccess;的属性,它的方法也是isSuccess(),RPC 框架在反向解析的时候,“以为”对应的属性名称是 success,导致属性获取不到,进而抛出异常。 【推荐】接口类中的方法和属性不要加任何修饰符号(public 也不要加),保持代码的简洁 性,并加上有效的 Javadoc 注释。尽量不要在接口里定义变量,如果一定要定义变量,肯定是与接口方法相关,并且是整个应用的基础常量。 正例: 接口方法签名:void f(); 接口基础常量表示:String COMPANY = “alibaba”; 反例: 接口方法定义:public abstract void f(); 说明:JDK8 中接口允许有默认实现,那么这个 default 方法,是对所有实现类都有价值的默认实现。 对于 Service 和 DAO 类,基于 SOA 的理念,暴露出来的服务一定是 接口,内部的实现类用 Impl 的后缀与接口区别。 正例:CacheServiceImpl 实现 CacheService 接口 【参考】各层命名规约: Service/DAO层方法命名规约 获取单个对象的方法用get做前缀。获取多个对象的方法用list做前缀。获取统计值的方法用count做前缀。插入的方法用save(推荐)或insert做前缀。删除的方法用remove(推荐)或delete做前缀。修改的方法用update做前缀。 领域模型命名规约 数据对象:xxxDO,xxx即为数据表名数据传输对象:xxxDTO,xxx为业务领域相关的名称展示对象:xxxVO,xxx一般为网页名称POJO是DO/DTO/BO/VO的统称,禁止命名成xxxPOJO 常量定义 不允许出现任何魔法值(即未经定义的常量)直接出现在代码中。 反例: 12String key=&quot;Id#taobao_&quot;+tradeId;&lt;br/&gt;cache.put(key, value); 如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外 的延伸属性,必须 使用 Enum 类,下面正例中的数字就是延伸信息, 表示星期几。 正例: 1234public Enum&#123; MONDAY(1), TUESDAY(2),WEDNESDAY(3),THURSDAY(4), FRIDAY(5),SATURDAY(6),SUNDAY(7);&#125; 格式规约 大括号的使用约定。如果是大括号内为空,则简洁地写成{}即可,不需要 换行;如果 是非空代码块则: 左大括号前不换行。左大括号后换行。右大括号前换行。右大括号后还有else等代码则不换行;表示终止右大括号后必须换 行。 左括号和后一个字符之间不出现空格;同样,右括号和前一个字符之间也 不出现空格。 if/for/while/switch/do 等保留字与左右括号之间都必须加空格。 任何运算符左右必须加一个空格。 说明:运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。 缩进采用 4 个空格,禁止使用 tab 字符。 说明:如果使用 tab 缩进,必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时,请勿勾选 Use tab character；而 eclipse 中,必须勾选 insert spaces for tabs。 正例： 123456789101112131415161718public static void main(String args[]) &#123; // 缩进 4 个空格 String say = &quot;hello&quot;; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格,括号内的 f 与左括号,0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125; // 左大括号前加空格且不换行;左大括号后换行 if (flag == 1) &#123; System.out.println(&quot;world&quot;); // 右大括号前换行,右大括号后有 else,不用换行 &#125; else &#123; System.out.println(&quot;ok&quot;); // 在右大括号后直接结束,则必须换行 &#125; &#125; 方法参数在定义和传入时,多个参数逗号后边必须加空格。 正例: 下例中实参的”a”,后边必须要有一个空格。 1method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); OOP 规约 避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成本,直接用类名来访问即可。 所有的覆写方法,必须加@Override 注解。可以准确判断是否覆盖成功 Object 的 equals 方法容易抛空指针异常,应使用常量或确定有值的对象来调用 equals。 正例: &quot;test&quot;.equals(object); 反例: object.equals(&quot;test&quot;); 说明:推荐使用java.util.Objects#equals (JDK7引入的工具类) 关于基本数据类型与包装数据类型的使用标准如下: 所有的POJO类属性必须使用包装数据类型。RPC方法的返回值和参数必须使用包装数据类型。所有的局部变量【推荐】使用基本数据类型。 定义 DO/DTO/VO 等 POJO 类时,不要设定任何属性默认值。 构造方法里面禁止加入任何业务逻辑,如果有初始化逻辑,请放在 init 方法中。 POJO 类必须写 toString 方法。使用 IDE 的中工具:source&gt;generate toString 时,如果继承了另一个 POJO 类,注意在前面加一下 super.toString。 说明:在方法执行抛出异常时,可以直接调用 POJO 的 toString()方法打印其属性值,便于排查问题。 使用索引访问用 String 的 split 方法得到的数组时,需做最后一个分隔符后有无内容的检查,否则会有抛 IndexOutOfBoundsException 的风险。 说明: 123String str = &quot;a,b,c,,&quot;;String[] ary = str.split(&quot;,&quot;); //预期大于 3,结果是 3millionSystem.out.println(ary.length); 类内方法定义顺序依次是:公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法。 setter 方法中,参数名称与类成员变量名称一致,this.成员名=参数名。在getter/setter 方法中,尽量不要增加业务逻辑,增加排查问题的难度。 反例: 123456public Integer getData()&#123; if (true) &#123;return data + 100; &#125; else &#123;return data - 100; &#125;&#125; 循环体内,字符串的联接方式,使用 StringBuilder 的 append 方法进行扩展。 反例: 1234String str = &quot;start&quot;; for (int i=0; i&lt;100; i++) &#123; str = str + &quot;hello&quot;; &#125; 说明:反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象,然后进行 append 操作,最后通过 toString 方法返回 String 对象,造成内存资源浪费。 final 可提高程序响应效率,声明成 final 的情况: 不需要重新赋值的变量，包括类属性、局部变量对象前加final，表示不允许修改引用的指向类方法确定不允许被重载 慎用 Object 的 clone 方法来拷贝对象。 说明:对象的 clone 方法默认是浅拷贝,若想实现深拷贝需要重写 clone 方法实现属性对象 的拷贝。 集合处理 关于 hashCode 和 equals 的处理,遵循如下规则: 只要重写equals,就必须重写hashCode。 因为Set存储的是不重复的对象,依据hashCode和equals进行判断,所以Set存储的 对象必须重写这两个方法。 如果自定义对象做为Map的键,那么必须重写hashCode和equals。 ArrayList的subList结果不可强转成ArrayList,否则会抛出ClassCastException 异常:java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ; 说明:subList 返回的是 ArrayList 的内部类 SubList,并不是 ArrayList ,而是 ArrayList 的一个视图,对于SubList子列表的所有操作最终会反映到原列表上。 在 subList 场景中,高度注意对原集合元素个数的修改,会导致子列表的遍历、增 加、删除均产生ConcurrentModificationException 异常。 使用集合转数组的方法,必须使用集合的toArray(T[] array),传入的是类型完全 一样的数组,大小就是 list.size()。 反例:直接使用 toArray 无参方法存在问题,此方法返回值只能是 Object[]类,若强转其它 类型数组将出现 ClassCastException 错误。 正例： 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);list.add(&quot;guan&quot;);list.add(&quot;bao&quot;);String[] array = new String[list.size()];array = list.toArray(array); 说明:使用 toArray 带参方法,入参分配的数组空间不够大时,toArray 方法内部将重新分配 内存空间,并返回新数组地址;如果数组元素大于实际所需,下标为[ list.size() ]的数组 元素将被置为 null,其它数组元素保持原值,因此最好将方法入参数组大小定义与集合元素 个数一致。 使用工具类 Arrays.asList()把数组转换成集合时,不能使用其修改集合相关的方 法,它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。 说明:asList 的返回对象是一个 Arrays 内部类,并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式,只是转换接口,后台的数据仍是数组。 12String[] str = new String[] &#123; &quot;a&quot;, &quot;b&quot; &#125;;List list = Arrays.asList(str); 第一种情况:list.add(“c”); 运行时异常。 第二种情况:str[0]= “gujin”; 那么list.get(0)也会随之修改。 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式,如果并发操作,需要对 Iterator 对象加锁。 反例: 12345678List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(&quot;1&quot;);a.add(&quot;2&quot;);for (String temp : a) &#123;if(&quot;1&quot;.equals(temp))&#123;a.remove(temp);&#125; &#125; 正例: 1234567Iterator&lt;String&gt; it = a.iterator(); while(it.hasNext())&#123; String temp = it.next(); if(删除元素的条件)&#123; it.remove(); &#125;&#125; 在 JDK7 版本以上,Comparator 要满足自反性,传递性,对称性,不然 Arrays.sort, Collections.sort 会报 IllegalArgumentException 异常。 说明: 自反性:x,y的比较结果和y,x的比较结果相反。传递性:x&gt;y,y&gt;z,则x&gt;z。对称性:x=y,则x,z比较结果和y,z比较结果相同。 反例:下例中没有处理相等的情况,实际使用中可能会出现异常: 123456new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getId() &gt; o2.getId() ? 1 : -1; &#125;&#125; 集合初始化时,尽量指定集合初始值大小。 说明:ArrayList尽量使用ArrayList(int initialCapacity) 初始化。 使用 entrySet 遍历 Map 类集合 KV,而不是 keySet 方式进行遍历。 说明:keySet 其实是遍历了 2 次,一次是转为 Iterator 对象,另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中,效 率更高。如果是 JDK8,使用 Map.foreach 方法。 keySet()返回的是 K 值集合,是 一个 Set 集合对象;entrySet()返回的是 K-V 值组合集合。 第一种: Map map = new HashMap(); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) { Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue(); } 效率高,以后一定要使用此种方式！ 第二种: Map map = new HashMap(); Iterator iter = map.keySet().iterator(); while (iter.hasNext()) { Object key = iter.next(); Object val = map.get(key); } 合理利用好集合的有序性(sort)和稳定性(order),避免集合的无序性(unsort)和 不稳定性(unorder)带来的负面影响。 说明:稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则 依次排列的。如:ArrayList 是 order/unsort;HashMap 是 unorder/unsort;TreeSet 是 order/sort。 利用 Set 元素唯一的特性,可以快速对一个集合进行去重操作,避免使用 List 的 contains 方法进行遍历、对比、去重操作。 12345678910111213// 删除ArrayList中重复元素，保持顺序public static void removeDuplicateWithOrder(List list)&#123; Set set = new HashSet(); List newList = new ArrayList(); for (Iterator iter = list.iterator(); iter.hasNext();) &#123; Object element = iter.next(); if (set.add(element)) newList.add(element); &#125; list.clear(); list.addAll(newList); System.out.println( &quot; remove duplicate &quot; + list); &#125; 高度注意 Map 类集合 K/V 能不能存储 null 值的情况,如下表格:|集合类|Key|Value|Super|说明|| —- | :–: | :–: | :–: | :–:||Hashtable|不允许为null|不允许为null|Dictionary|线程安全||ConcurrentHashMap|不允许为 null|不允许为 null|AbstractMap|分段锁技术||TreeMap|不允许为 null|允许为 null|AbstractMap|线程不安全||HashMap|允许为 null|允许为 null|AbstractMap|线程不安全| 并发处理 获取单例对象需要保证线程安全,其中的方法也要保证线程安全。 说明:资源驱动类、工具类、单例工厂类都需要注意。 创建线程或线程池时请指定有意义的线程名称,方便出错时回溯。 123456正例:public class TimerTaskThread extends Thread &#123; public TimerTaskThread()&#123; super.setName(&quot;TimerTaskThread&quot;); ... &#125;&#125; 线程资源必须通过线程池提供,不允许在应用中自行显式创建线程。 说明:使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销,解决资 源不足的问题。如果不使用线程池,有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。 线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样 的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险。 说明:Executors 返回的线程池对象的弊端如下: 1)FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE,可能会堆积大量的请求,从而导致 OOM。 2)CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE,可能会创建大量的线程,从而导致 OOM。 SimpleDateFormat 是线程不安全的类,一般不要定义为static变量,如果定义为static,必须加锁,或者使用 DateUtils 工具类。 正例:注意线程安全,使用 DateUtils。亦推荐如下处理: private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() { @Override protected DateFormat initialValue() { return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); } }; 说明:如果是 JDK8 的应用,可以使用 Instant 代替 Date,LocalDateTime 代替Calendar, DateTimeFormatter 代替 Simpledateformatter,官方给出的解释:simple beautiful strong immutable thread-safe。 高并发时,同步调用应该去考量锁的性能损耗。能用无锁数据结构,就不要用锁;能 锁区块,就不要锁整个方法体;能用对象锁,就不要用类锁。 对多个资源、数据库表、对象同时加锁时,需要保持一致的加锁顺序,否则可能会造 成死锁。 说明:线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作,那么线程二的加锁顺序 也必须是 A、B、C,否则可能出现死锁。 并发修改同一记录时,避免更新丢失,要么在应用层加锁,要么在缓存加锁,要么在 数据库层使用乐观锁,使用 version 作为更新依据。 说明:如果每次访问冲突概率小于 20%,推荐使用乐观锁,否则使用悲观锁。乐观锁的重试次 数不得小于 3 次。乐观锁和悲观锁 多线程并行处理定时任务时,Timer 运行多个 TimeTask 时,只要其中之一没有捕获 抛出的异常,其它任务便会自动终止运行,使用 ScheduledExecutorService 则没有这个问题。详解 使用 CountDownLatch 进行异步转同步操作,每个线程退出前必须调用 countDown方法,线程执行代码注意 catch 异常,确保 countDown 方法可以执行,避免主线程无法执行 至 countDown 方法,直到超时才返回结果。 说明:注意,子线程抛出异常堆栈,不能在主线程 try-catch 到。 避免 Random 实例被多线程使用,虽然共享该实例是线程安全的,但会因竞争同一 seed 导致的性能下降。 说明:Random 实例包括 java.util.Random 的实例或者 Math.random()实例。 正例:在 JDK7 之后,可以直接使用 API ThreadLocalRandom,在 JDK7 之前,可以做到每个 线程一个实例。 通过双重检查锁(double-checked locking)(在并发场景)实现延迟初始化的优 化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题 解决方案中较为简单一种(适用于 JDK5 及以上版本),将目标属性声明为 volatile 型。 1234567891011反例:class Foo &#123; private Helper helper = null; public Helper getHelper() &#123; if(helper==null) synchronized(this)&#123; if (helper == null) helper = new Helper(); &#125; return helper; &#125; // other functions and members...&#125; volatile 解决多线程内存不可见问题。对于一写多读,是可以解决变量同步问题, 但是如果多写,同样无法解决线程安全问题。如果是 count++操作,使用如下类实现: AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8,推 荐使用 LongAdder 对象,比 AtomicLong 性能更好(减少乐观锁的重试次数) HashMap 在容量不够进行 resize 时由于高并发可能出现死链,导致 CPU 飙升,在 开发过程中注意规避此风险。 ThreadLocal 无法解决共享对象的更新问题,ThreadLocal 对象建议使用 static 修饰。这个变量是针对一个线程内所有操作共有的,所以设置为静态变量,所有此类实例共享 此静态变量 ,也就是说在类第一次被使用时装载,只分配一块存储空间,所有此类的对象(只 要是这个线程内定义的)都可以操控这个变量。 控制语句 在一个 switch 块内,每个 case 要么通过 break/return 等来终止,要么注释说明程 序将继续执行到哪一个 case 为止;在一个 switch 块内,都必须包含一个 default 语句并且 放在最后,即使它什么代码也没有。 在 if/else/for/while/do 语句中必须使用大括号,即使只有一行代码,避免使用 下面的形式:if (condition) statements; 推荐尽量少用 else, if-else 的方式可以改写成: if(condition){ ... return obj; } // 接着写 else 的业务逻辑代码; 说明:如果非得使用 if()…else if()…else…方式表达逻辑,【强制】请勿超过 3 层,超过请使用状态设计模式。 正例:逻辑上超过 3 层的 if-else 代码可以使用卫语句,或者状态模式来实现。 除常用方法(如 getXxx/isXxx)等外,不要在条件判断中执行其它复杂的语句,将复 杂逻辑判断的结果赋值给一个有意义的布尔变量名,以 高可读性。说明:很多 if 语句内的逻辑相当复杂,阅读者需要分析条件表达式的最终结果,才能明确什么 样的条件执行什么样的语句,那么,如果阅读者分析逻辑表达式错误呢? 正例: //伪代码如下 boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...); if (existed) { ... } 反例: if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) { ... } 循环体中的语句要考量性能,以下操作尽量移至循环体外处理,如定义对象、变量、获取数据库连接,进行不必要的 try-catch 操作(这个 try-catch 是否可以移至循环体外)。 接口入参保护,这种场景常见的是用于做批量操作的接口。 方法中需要进行参数校验的场景: 1) 调用频次低的方法。 2) 执行时间开销很大的方法,参数校验时间几乎可以忽略不计,但如果因为参数错误导致中间执行回退,或者错误,那得不偿失。 3) 需要极高稳定性和可用性的方法。 4) 对外 供的开放接口,不管是RPC/API/HTTP接口。 5) 敏感权限入口。 方法中不需要参数校验的场景: 1) 极有可能被循环调用的方法,不建议对参数进行校验。但在方法说明里必须注明外部参数检查。 2) 底层的方法调用频度都比较高,一般不校验。毕竟是像纯净水过滤的最后一道,参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中,部署在同一 台服务器中,所以 DAO 的参数校验,可以省略。 3) 被声明成private只会被自己代码所调用的方法,如果能够确定调用方法的代码传入参 数已经做过检查或者肯定不会有问题,此时可以不校验参数。 注释规约 类、类属性、类方法的注释必须使用 Javadoc 规范,使用/*内容/格式,不得使用 //xxx 方式。 方法内部单行注释,在被注释语句上方另起一行,使用//注释。方法内部多行注释使用/ /注释,注意与代码对齐。 代码修改的同时,注释也要进行相应的修改,尤其是参数、返回值、异常、核心逻辑 等的修改。 其它 在使用正则表达式时,利用好其预编译功能,可以有效加快正则匹配速度。 说明:不要在方法体内定义:Pattern pattern = Pattern.compile(规则); 123456A typical invocation sequence is thus:Pattern p = Pattern.compile(&quot;a*b&quot;);Matcher m = p.matcher(&quot;aaaaab&quot;);boolean b = m.matches();is equivalent to :boolean b = Pattern.matches(&quot;a*b&quot;, &quot;aaaaab&quot;); 注意 Math.random() 这个方法返回是 double 类型,注意取值的范围 0≤x&lt;1(能够取到零值,注意除零异常),如果想获取整数类型的随机数,不要将 x 放大 10 的若干倍然后取整,直接使用 Random 对象的 nextInt 或者 nextLong 方法。 获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();说明:如果想获取更加精确的纳秒级时间值,用 System.nanoTime()。在 JDK8 中,针对统计时间等场景,推荐使用 Instant 类。 任何数据结构的构造或初始化,都应指定大小,避免数据结构无限增长吃光内存。 异常日志异常处理 不要捕获 Java 类库中定义的继承自 RuntimeException 的运行时异常类,如: IndexOutOfBoundsException / NullPointerException,这类异常由程序员预检查 来规避,保证程序健壮性。 12正例:if(obj != null) &#123;...&#125;反例:try &#123; obj.method() &#125; catch(NullPointerException e)&#123;...&#125; 异常不要用来做流程控制,条件控制,因为异常的处理效率比条件分支低。 对大段代码进行 try-catch,这是不负责任的表现。catch 时请分清稳定代码和非稳定代码,稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分 异常类型,再做对应的异常处理。 捕获异常是为了处理它,不要捕获了却什么都不处理而抛弃之,如果不想处理它,请将该异常抛给它的调用者。最外层的业务使用者,必须处理异常,将其转化为用户可以理解的内容。 finally 块必须对资源对象、流对象进行关闭,有异常也要做 try-catch。 说明:如果 JDK7,可以使用 try-with-resources 方式。 不能在 finally 块中使用 return,finally 块中的 return 返回后方法结束执行,不会再执行 try 块中的 return 语句。 定义时区分unchecked/checked 异常,避免直接使用RuntimeException抛出, 更不允许抛出 Exception 或者 Throwable,应使用有业务含义的自定义异常。推荐业界已定义 过的自定义异常,如:DAOException / ServiceException 等。 日志规约 应用中不可直接使用日志系统(Log4j、Logback)中的 API,而应依赖使用日志框架SLF4J 中的 API,使用门面模式的日志框架,有利于维护和各个类的日志处理方式统一。 123import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Abc.class); 日志文件推荐至少保存 15 天,因为有些异常具备以“周”为频次发生的特点。 对 trace/debug/info 级别的日志输出,必须使用条件输出形式或者使用占位符的方式。 说明:logger.debug(“Processing trade with id: “ + id + “ symbol: “ + symbol); 如果日志级别是 warn,上述日志不会打印,但是会执行字符串拼接操作,如果 symbol 是对象, 会执行 toString()方法,浪费了系统资源,执行了上述操作,最终日志却没有打印。 123456正例:(条件)if (logger.isDebugEnabled()) &#123;logger.debug(&quot;Processing trade with id: &quot; + id + &quot; symbol: &quot; + symbol);&#125;正例:(占位符)logger.debug(&quot;Processing trade with id: &#123;&#125; symbol : &#123;&#125; &quot;, id, symbol); 避免重复打印日志,浪费磁盘空间,务必在 log4j.xml 中设置 additivity=false。 正例:&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt; 异常信息应该包括两类信息:案发现场信息和异常堆栈信息。如果不处理,那么往上抛。 正例:logger.error(各类参数或者对象 toString + &quot;_&quot; + e.getMessage(), e); 可以使用 warn 日志级别来记录用户输入参数错误的情况,避免用户投诉时,无所适从。 MySQL 规约待续。。。源引自：阿里巴巴Java开发手册]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown之说]]></title>
      <url>%2F2016%2F11%2F20%2Fmarkdown%E4%B9%8B%E8%AF%B4%2F</url>
      <content type="text"><![CDATA[之所以写这篇文章也很明显，因为写博客是采用的Markdown格式的，还是再熟悉下Markdown的基本语法吧 Markdown简明语法手册 1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例：这是斜体，这是 粗体 2. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 12345这是一个一级标题===============================这是一个二级标题-------------------------------### 这是一个三级标题 也可以选择在行首添加不同个数的#号表示不同级别的标题（H1~H6），例如：# H1, ## H2, ### H3, #### H4。注意#号后面要跟空格。 3. 外链接使用 [描述]（链接地址）为文字增加外链接。 示例： 这是去往本人博客的链接。 4. 无序列表使用 *，+，— 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 朝辞白帝彩云间千里江陵一日还两岸猿声啼不住轻舟已过万重山 注意：hexo-admin 好像不支持这个预览，这个比较坑，求推荐更好的插件 7. 行内代码块使用`代码` 表示行内代码块。 示例： 让我们聊聊html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址)插入图像。 示例： Markdown高阶语法 1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： java go Markdown 或者 Tags：java go Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 注意~~后面不要留空格 4. 注脚使用 [^keywork] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 hexo-admin 预览没效果 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$ $$\sum^{j-1}{k=0}{\widehat{\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 表格支持12345| 项目 | 价格 | 数量 || -------- | ----: | :----: || 计算机 | \$1600 | 5 || 手机 | \$12 | 12 || 管线 | \$1 | 234 | 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 9. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： 12345678910111213&lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 10. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 注意：经验证原生的不支持 [^footnote]: 这是一个 注脚 的 文本。 [^footnote2]: 这是另一个 注脚 的 文本。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux expert]]></title>
      <url>%2F2016%2F10%2F16%2FLinux-expert%2F</url>
      <content type="text"><![CDATA[在开发运维当中，一些基本的 linux 命令还是要掌握一些的 命令基本格式[root@localhost ~]#123456其中：root 当前登录用户 localhost 主机名 ~ 当前所在目录（家目录） # 超级用户的提示符 普通用户的提示符是 `$`命令 [选项] [参数] 注意：a.个别不遵循 b.多个选项可以写在一起 c.简化选项与完整选项 -a等于--all 查询目录中的内容lsls [选项] [文件或目录] 选项： -a 显示所有文件，包括隐藏文件 -l 显示详细信息 -d 查看目录的属性 -h 人性化显示文件大小 -i 显示inode 每个文件都有id号 查找时根据id查找 -rw-r--r--. 22 root root 4096 7月 27 22:12 var 第一字符代表文件类型：-代表文件 d 代表目录 | 代表软连接文件 总共有七种文件类型主要掌握三种 第一位除外，每三个一组 rw- :u所有者 r--:g所属组 r--:o其它人 字母含义：r读 w写 x执行 最后一个点：ACL权限 22：引用计数 root:用户 root:组 4096：代表文件大小为4096字节 可以规范化显示大小 ls -lh h可以显示kb 文件处理命令目录处理命令建立目录mkdir -p [目录名] -p 递归创建 递归创建意思是 一级一级往下创建目录 直到最底层 切换目录命令cd [目录] 简化操作： cd ~ 进入当前用户的家目录 cd 进入当前用户的家目录 cd - 进入上次目录 cd .. 进入上一级目录 cd . 进入当前目录 pwd 显示当前用户所在位置tab键 命令或文件或目录补全删除空目录rmdir [目录名] 删除文件或目录rm -rf [文件或目录] 选项： -r 删除目录 -f 强制 文件处理命令链接命令a.硬链接 创建命令： ln 文件 文件硬连接名[.hard] 拥有相同的i节点和存储block块，可以看作同一个文件 可通过i节点识别 ls -i 文件1 文件2(硬链接) 不能跨分区 不能针对目录使用 b.软连接 创建命令：ln -s 文件 文件软连接名[.soft] 类似windows快捷方式 拥有自己的i节点和block块，但数据块中存储源文件的文件名和i节点 lrwxrwxrwx l软连接 修改任意一个都改变 文件搜索命令locate搜索命令locate 文件名 在后台数据库中搜索文件名，搜索速度较快，只能通过文件名搜索 /var/lib/mlocate locate命令搜索的后台数据库 一般一天一更新 可通过updatedb命令手动更新 locate搜索按照 /etc/updatedb.conf 配置规则进行搜索 命令搜索命令whereis 和 whichshell中的内置命令不能使用 (1) whereis 命令名 #搜索命令所在路径及帮助文档所在位置 选项： -b：只查找可执行文件 -m:只查找帮助文件 (2)which 命令名 #搜索命令所在路径及显示命令的别名 find命令find [搜索范围] [搜索条件] #搜索指定范围的文件 如：find / -name install.log #避免大范围搜索，会非常消耗系统资源 #find 在系统中搜索指定文件名的文件，默认完整匹配；若模糊匹配，要使用通配符 *匹配任意内容 ?匹配任意一个字符 []匹配中括号内的字符 find /root -iname install.log #-iname不区分大小写 find /root -user root #按照所有者搜索文件 find /root -nouser #搜索没有所有者的文件 即垃圾文件 find /var/log/ -mtime +10 #查找10天前修改的文件 -10 10天内 10 10天当天 +10 10天前 actime 文件访问的时间 ctime 文件创建的时间 mtime 修改文件内容 find . -size 25k #查找文件大小是25kb的文件 -25k 小于25kb的文件 25k 等于25kb的文件 +25k 大于25kb的文件 find . inum 262422 #查找i节点是262422的文件 find /ect -size +20k -a -size -50k #查找etc目录下 大于20kb并且小于50kb的文件 -a and 逻辑与 -o or 逻辑或 find /ect -size +20k -a -size -50k -exec ls -lh {}\; #查找etc目录下 大于20kb并且小于50kb的文件，并显示详细信息 #exec/-ok 命令 ｛｝\;固定格式；对搜索结果执行操作； 搜索字符串命令grep [选项] 字符串 文件名 #在文件中匹配符合条件的字符串 选项：-i 忽略大小写 -v 排除指定字符串 帮助命令man帮助命令 man 命令 #获取指定命令的帮助 执行man命令之后可输入 /content 查询content man的级别 1:查看命令的帮助 2：查看可被内核调用的函数的帮助 3：查看函数和函数库的帮助 4：查看特殊文件的帮助(主要是/dev目录下的文件) 5：查看配置文件的帮组 6：查看游戏的帮助 7：查看其它杂项的帮助 8：查看系统管理员可用命令的帮助 9：查看和内核相关文件的帮助 man -f 命令名 #查看某个命令有哪个级别的帮助 该命令相当于： whatis 命令 举例： man 5 passwd man 4 null man -8 ifconfig man -k 命令 相当于 apropos 命令 #查看和命令相关的所有帮助 例如： apropos passwd 其它帮助命令 --help #获取命令选项的帮助 例如：ls --help shell内部帮助命令 help shell内部命令 #获取shell内部命令的帮助 例如： whereis cd #确定是否是shell内部命令 --找不到执行路径的就是内部命令 help cd #获取内部命令帮助 压缩命令linux常用压缩格式 .zip .gz .bz2 .tar.gz .tar.bz2 .zip格式压缩zip 压缩文件名 源文件 #压缩文件 zip -r 压缩文件名 源目录 #压缩目录 unzip 压缩文件 #解压缩.zip文件 .gz格式压缩gzip 源文件 #压缩为.gz格式的压缩文件，源文件会消失 gzip -c 源文件 &gt; 压缩文件 #压缩为.gz格式，源文件保留 例如：gzip -c cangls &gt; cangls.gz gzip -r 目录 #压缩目录下所有的子文件,单个，但是不能压缩目录 gzip -d 压缩文件 #解压缩文件 或 gunzip 压缩文件 #解压缩文件 .bz2格式压缩bzip2 源文件 #压缩为.bz2格式，不保留源文件 bzip2 -k 源文件 #压缩之后保留源文件 注意：bzip2命令不能压缩目录 bzip2 -d 压缩文件 #解压缩，-k保留压缩文件 或 bunzip2 压缩文件，-k 保留压缩文件 打包命令tartar -cvf 打包文件名 源文件 选项： -c:打包 -v:显示过程 -f:指定打包后的文件名 例如： tar -cvf longzls.tar longzls tar -xvf 打包文件名 选项： -x:解打包 例如：tar -xvf longzls.tar .tar.gz压缩格式其实就是先打包为.tar格式，再压缩为.gz格式 tar -zcvf 压缩包名.tar.gz 源文件 选项： -z:压缩为.tar.gz格式 tar -zxvf 压缩包名.tar.gz 选项： -x:解压缩.tar.gz格式 .tar.bz2压缩格式其实就是先打包为.tar格式，再压缩为.bz2格式 tar -jcvf 压缩包名.tar.bz2 源文件 选项： -z:压缩为.tar.bz2格式 tar -jxvf 压缩包名.tar.bz2 选项： -x:解压缩.tar.bz2格式 技巧(1)指定解压缩位置 tar -zxvf 压缩包名.tar.gz -c /tmp/ 选项： -c:指定解压缩的具体位置 (2)压缩多个文件,并指定压缩文件所在位置 tar -zcvf /tmp/test.tar.gz jp a.cfg #将jp文件夹及a.cfg文件压缩到/tmp/test.tar.gz (3)只查看不解压 tar -ztvf test.tar.gz #查看压缩文件test.tar.gz的内容 选项-t代表查看压缩文件的内容 关机与重启命令shutdown命令shutdown [选项] 时间 选项 -c:取消前一个关机命令 -h:关机 -r:重启 时间可以是now就是立刻重启 例如：shutdown -r 05:30 &amp; #在凌晨五点半重启电脑，&amp;的意思是放后台执行，前台仍可以进行其它操作 shutdown -c #取消上面的重启命令 其它关机命令halt poweroff init 0 这几个没有shutdown命令安全，shutdown是保存数据库再做操作，而这几个就不一定保存数据 其它重启命令reboot init 6 reboot 重启也是比较安全的，但init 6就不安全 系统运行级别0：关机 1：单用户(类似windows中安全模式) 2：不完全多用户，不含NFS服务(文件共享服务) 3：完全多用户 4：未分配 5：图形界面 6：重启 查看系统运行级别 runlevel 显示：N 3 #N代表上一个运行级别为空，当前运行级别为3 修改系统登录时默认运行级别： centos6以前： vi /ect/inittab中修改 id:3:initdefault: 退出登录命令logout 其它常用命令挂载命令(1)查询与自动挂载 mount #查询系统中已经挂载的设备 mount -a #依据配置文件/etc/fstab的内容，自动挂载 (2)、挂载命令格式 mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点 选项： -t 文件系统：加入文件系统类型来指定挂载待类型，可以ext3、ext4、iso9660(挂载光盘使用d文件系统)等 -o 特殊选项：可以指定挂载待额外选项 自行百度 mount -o remount,noexec /home/ #remount重新挂载，noexec是挂载的系统没有执行权限，没写文件系统是因为 /home/是默认挂载好的，已经知道文件系统类型 (3)、挂载光盘 mnt 一般是挂载u盘待目录 media 一般是挂载光盘待目录 misc 一般是挂载磁带机的目录 既然是一般，当然也可根据习惯挂载其它目录 下面我们在mnt下创建cdrom挂载光盘 创建usb挂载U盘 mkdir /mnt/cdrom #创建光盘挂载点 mount [-t iso9660] /dev/sr0/ /mnt/cdrom #挂载光盘 注意/dev/sr0 其中sr0是光盘的设备文件名 /dev/cdrom是/dev/sr0的软连接 可以去/mnt/cdrom下挂载的内容 (4)、卸载命令 umount 设备文件名或挂载点 umount /mnt/cdrom/ 或 umount /dev/sr0/ #卸载光盘 注意：为了防止出错，用完后一定要卸载 (5)、挂载U盘 因为u盘设备文件名不固定，先查看设备文件名 fdisk -l #查看U盘设备文件名 mkdir /mnt/usb #创建U盘挂载点 mount -t vfat /dev/sdb1 /mnt/usb # vfat 代表文件系统为fat32(单个文件最大4G) /dev/sdb1为U盘设备文件名(以查到的为准) 注意：Linux 默认不支持NTFS系统 用户登录查看命令(1)w [用户名] #查看指定用户登录情况 w #查看所有登录用户 结果： 08:48:09 up 16:51, 2 users, load average: 0.00, 0.01, 0.05 USER TTY LOGIN@ IDLE JCPU PCPU WHAT root tty1 六17 15:07m 0.07s 0.07s -bash root pts/0 07:22 1.00s 0.24s 0.03s w #其中： 08:48:09 up 16:51 系统到08:48:09运行了16小时51分钟 2 users 总共两个用户登录 load average 系统在1分钟 5分钟 和15分钟占据的负载压力 USER:登录用户名 TTY:登录终端 tty1代表本机登陆 pts/0代表远程终端 FROM:从哪个ip地址登录； LOGIN@:登录时间； IDLE：用户闲置时间； JCPU：指的是和该终端链接的所有进程占用的时间。这个时间里并不包括过去的 后台作业时间,但却包括当前正在运行的后台作业所占用的时间； PCUP:是指当前进程所占用的时间 WHAT:当前正在运行的命令 (2)who [用户名] 功能与w命令相似 who #命令输出： -用户名 -登录终端 -登录时间(登录来源ip地址) (3)last 查询当前登录和过去登录的用户信息 last命令默认读取/var/log/wtmp文件数据 last #命令输出： -用户名 -登录终端 -登录ip -登录时间 -退出时间(在线时间) (4)lastlog 查看系统所有用户最后登录时间 lastlog命令默认读取/var/log/lastlog文件数据 lastlog #命令输出： -用户名 -登录终端 -登录ip -最后一次登录时间 shell基础shell概述(1)、shell概述 *shell 是一个命令行解释器，它为用户提供了一个向linux内核发送请求以便 运行程序待界面系统程序，用户可以通过shell启动、挂起、停止甚至编写 一些程序 *shell还是一个功能相当强大的编程语言，在shell中可以直接调用linux系统命令 (2)、shell分类 *Bourne Shell:1979开始使用，Bourne Shell的主文件名为sh 基本已淘汰 *C Shell:主要在BSD版的Unix系统中使用，其语法和c语言相似 *Shell 两种主要语法有Bourn和C，两种语法不兼容。 Bourn家族主要包括sh、ksh、Bash(linux标准shell)、psh、zsh;C家族主要有：csh、tcsh echo $SHELL #查看系统使用的shell版本 echo 代表输出 $ 调用变量 SHELL为shell的变量名 (3)、查看系统支持shell cat /etc/shells #查看兼容的所有shell版本 切换shell输入相应shell版本名称即可 sh #将shell版本切换为sh exit退出子shell 脚本执行方式(1)echo 输出命令 echo [选项] [输出内容] 选项： -e:支持反斜线控制的字符转换 echo &quot;Today is sunday.Where we go?&quot; #在屏幕输出 Today is sunday.Where we go? 注意：有空格就要用引号 echo -e &quot;Today is\b sunday.Where we go?&quot; #在屏幕输出 Today i sunday.Where we go? 少了一个s 支持的字符转换： \a 输出警告音 \b 退格键，也就是向左删除键 \n 换行键 \r 回车键 \t 制表符 tab键 \v 垂直制表符 \0nnn 按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数 \xhh 按照16进制ASCII码表输出字符。其中hh是两位十六进制数 echo -e &quot;\e[1;31m 嫁人就要嫁凤姐\e[0m&quot; #以红色字体显示：嫁人就要嫁凤姐 \e[1; 是开启颜色 31m=红色 \e[0m是关闭颜色显示 #输出颜色 30m=黑色 31=红色 32m=绿色 33m=黄色 34m=蓝色 35m=洋红 36m=青色 37m=白色 (2)第一个脚本 vim hello.sh #创建文件hello.sh 在hello.sh中输入下面内容： #!/bin/bash #The first program echo -e &quot;\e[1;31m天上掉下个林妹妹\e[0m&quot; 注意：#!/bin/bash 这句比较特殊不是注释 声明该脚本为bash脚本 必须添加 不然复杂脚本可能报错 (3)执行一个脚本 a.赋予执行权限，直接运行 chmod 755 hello.sh ./hello.sh b. 通过bash调用执行脚本 bash hello.sh bash的基本功能(1)命令别名与快捷键 alias #查看系统中所有命令的别名 alias 别名=&apos;原命令&apos; #设定命令别名(重启失效) vi ~/.bashrc #修改家目录下的bashrc文件 使别名永久生效 默认重新登陆生效 也可使用 source .bashrc命令使立即生效 unalias 别名 #删除别名(重启失效) 若要永久生效 删除bashrc中定义的别名 并使用source .bashrc命令使其不用重新登陆就可以立即生效 命令生效顺序： *第一顺位 使用绝对路径或相对路径执行命令 *第二顺位 执行别名 *第三顺位 执行bash的内部命令 *第四顺位 从$PATH中查找到的第一个命令 快捷键： ctrl+c 强制终止当前命令 ctrl+l 清屏 ctrl+a 光标移动到命令的首行 ctrl+e 光标移动到命令的行尾 ctrl+u 从光标所在的位置删除到行首 ctrl+z 把命令放入后台 ctrl+r 在历史命令中搜索 (2)历史命令 history [选项] [历史命令保存文件] 选项: -c ：清空历史命令 -w ：把缓存中的历史命令写入到历史命令保存文件~/.bash_history 历史命令的调用 *使用上下箭头调用以前的命令 *使用!n重复执行第n条历史命令 *使用!!重复执行上一条命令 *使用&quot;!字串&quot; 重复执行最后一条以该字串开头的命令 命令与文件补全 *在bash中，按&quot;Tab&quot;键自动进行补全 (3)输出重定向 &lt;1&gt;标准输入输出 设备 设备文件名 文件描述符 类型 键盘 /dev/stdin 0 标准输入 显示器 /dev/sdtout 1 标准输出 显示器 /dev/sdterr 2 标准错误输出 &lt;2&gt;输出重定向 类型 符号 作用 标准输出重定向 命令&gt;文件 以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中 标准输出重定向 命令&gt;&gt;文件 以追加的方式，把命令的正确输出输出到指定的文件或设备当中 标准错误输出重定向 错误命令 2&gt;文件 以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中 标准错误输出重定向 错误命令 2&gt;&gt;文件 以追加的方式，把命令的正确输出输出到指定的文件或设备当中 正确输出和错误输出同时保存 命令&gt;文件 2&gt;&amp;1 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中 正确输出和错误输出同时保存 命令&gt;&gt;文件 2&gt;&amp;1 以追加的方式，把正确输出和错误输出都保存到同一个文件当中 正确输出和错误输出同时保存 命令 &amp;&gt;文件 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中 正确输出和错误输出同时保存 命令 &amp;&gt;&gt;文件 以追加的方式，把正确输出和错误输出都保存到同一个文件当中 正确输出和错误输出同时保存 命令&gt;&gt;文件1 2&gt;&gt;文件2 把正确的输出追加到文件1中，把错误的输出追加到文件2中 #上面的2代表文件描述符 意思是当出错时 把错误信息输出到文件 并且2后面不能有空格 ls &amp;&gt;/dev/null #将执行结果直接丢弃 既不显示在屏幕上，也不保存到文件中 null相当于windows系统中垃圾回收站 (4)输入重定向 wc [选项][文件名] 选项: -c: 统计字节数 -w: 统计单词数 -l: 统计行数 输入wc 输入sdfds 按ctrl+d 统计行数 单词数 字符数 *命令&lt;文件 #把文件作为命令的输入 *命令&lt;&lt;标识符 (5)管道符 &lt;1&gt;多命令顺序执行 多名令执行符 格式 作用 ; 命令1;命令2 多个命令顺序执行，命令之间没有任何逻辑关系 &amp;&amp; 命令1&amp;&amp;命令2 逻辑与；当命令1正确执行，命令2才会执行；当命令1不正确，命令2不会执行 || 命令1||命令2 逻辑或；当命令1执行不正确，命令2才会执行；当命令1正确，命令2不会执行 &lt;2&gt;管道符 命令格式： 命令1 | 命令2 #命令1的正确输出作为命令2的操作对象 netstat -an | grep ESTABLISHED #从netstat -an执行结果中搜索ESTABLISHED (6)通配符 &lt;1&gt; 通配符 通配符 作用 ？ 匹配一个任意字符 * 匹配0个或任意多个字符，也就是可以匹配任意内容 [] 匹配括号中任意一个字符。例如[abc]代表匹配a或b或c [-] 匹配括号中任意一个字符，-代表范围。例：[a-z]代表匹配一个小写字母 [^] 逻辑非，表示匹配不是中括号内的一个字符。例如：[^0-9]代表匹配一个不是数字的字符 &lt;2&gt;Bash中其它特殊符号 VIM文本编辑器VIM文本编辑器概述*vi---&gt;VIM VIM是VI升级版 *VIM相对VI做了哪些提升 -VIM支持多级撤销(u) -VIM可以跨平台运行 vi只能运行在以unix为内核的系统中 VIM可以运行在其它平台(如linux) -VIM支持语法高亮 -VIM支持图形界面 VIM操作模式和命令模式*command mode -命令模式 *insert mode -插入模式 *last line mode -底行模式(尾行、末行) vim abc #打开abc，若没有创建abc并打开 首先进入命令模式---&gt;i键进入插入模式---&gt;esc键进入底行模式 :wq 保存退出 :q或:q! 不保存退出 命令模式下 dd表示删除一行 vim +[i] abc #打开abc 并定位到最后一行(第i行) vim +/alvin abc #打开abc，并定位到alvin第一次出现的地方 n可以在多个alvin之间切换 vim aa bb cc #若不存在创建多个文件，若存在打开多个文件 底行模式下输入n切换到下一个文件 输入prev或N切换到上一个文件 底行模式和命令模式常用命令(1)底行模式常用命令 (2)命令模式常用命令 -h 光标左移 -j 光标下移 -k 光标上移 -l 光标右移 -ctrl+f 向下翻页(front) -ctrl+b 向上翻页(back) -ctrl+d 向下翻半页(down) -ctrl+u 向上翻半页(up) -dd 删除光标所在一行 -o 在光标所在位置下方插入一行并切换到插入模式 -yy 复制光标所在的一行 -p 在光标所在行的下方粘贴 磁盘管理磁盘管理基本命令df 查看磁盘分区使用情况 -l 仅显示本地磁盘(默认) -a 显示所有文件系统的磁盘使用情况，包含比如/proc/ -h 以1024进制计算最合适的单位显示磁盘容量 -H 以1000进制计算最合适的单位显示磁盘容量 -T 显示磁盘分区类型 -t 显示指定文件系统的磁盘分区 -x 不显示指定文件系统的磁盘分区 du 统计磁盘上的文件大小 -b 以byte为单位统计文件 -k 以kb为单位统计文件 -m 以mb为单位统计 -h 以1024进制计算最合适的单位显示磁盘容量 -H 以1000进制计算最合适的单位显示磁盘容量 -s 指定统计目标 跟参数 硬盘分区和格式化概述在服务器挂载新的硬盘 在VM虚拟机中添加硬盘场景:硬盘空间不够用 需添加新硬盘 MBR分区(已经过时)-主分区不超过4个 -单个分区容量最大2TB fdisk -l #查看硬盘大小及分区情况 fdisk 未分区硬盘文件名 #进入分区模式 输入n 新增一个分区---&gt;选择主分区或者扩展分区---&gt;输入分区编号(1-4)---&gt;指定扇区开始位置----&gt;指定扇区结束位置或指定分区大小 GPT分区-主分区个数&quot;几乎&quot;没有限制(最多支持128个主分区) -单个分区容量&quot;几乎&quot;没有限制(最多支持18EB) 1EB=1024PB,1PB=1024TB parted #启动分区工具 select /dev/sdc #切换到待分区的硬盘 mklable gpt(或者msdos msdos就是mbr) #指定要用的分区表 print #查看当前硬盘分区详情 print all #查看所有硬盘分区详情 交互方式添加分区： mkpart #添加分区 添加分区名称---&gt;指定分区文件系统类型默认为ext2---&gt;指定开始MB 一般从1MB开始 预留1M左右4k对齐--&gt;指定结束MB---&gt;print查看目前分区状况 命令模式添加分区(不同于上面的方式) mkpart test 2000 3000 #添加名称为test的分区 指定MB区间为2000-3000MB rm n #删除编号为n的分区 unit GB #默认分区大小单位MB,使用unit命令指定分区单位为GB 若添加的分区重叠：会给出警告，系统给出建议性提示分区大小 分区的格式化mkfs.ext3 /dev/sdb1 #格式化 sdb1硬盘 指定系统文件类型为ext3 mkfs -t dext4 /dev/sdb2 #为另一种格式化方式 将sdb2格式化为ext4 挂载分区分区--&gt;格式化--&gt;挂载 经过这个过程才能使用硬盘 mkdir -p /mnt/alvin #创建挂载目录 mount /dev/sdb1 /mnt/alvin #挂载sdb1硬盘 指定挂载点为alvin umount /mnt/alvin #卸载挂载 参数为挂载点 mount挂载重启挂载失效 解决方法如下： vim + /etc/fstab #在fstab末添加 ： /dev/sdb1 /mnt/alvin ext3 defaults 0 0 该方法挂载永久有效 swap 交换分区创建交换分区步骤： 第一，建立一个普通的linux分区 第二，修改分区类型的16进制编码 第三，格式化交换分区 第四，启用交换分区 fdisk /dev/sdb #查看硬盘大小及分区情况 输入t--&gt;输入分区编号---&gt;指定交换分区hex code编号--&gt;输入w保存 mkswap /dev/sdb6 #格式化交换分区 swapon /dev/sdb6 #启用交换分区 free #查看swap加载状况 swapoff /dev/sdb6 #停止交换分区 用户管理用户和用户组的概念用户：使用操作系统的人 用户组：具体相同权限的一组用户 * /etc/group 存储当前系统中所有用户组信息 -Group: x : 123 :abc,def,xyz -组名称： 组密码占位符 ： 组编号 ：组中用户名列表 说明：root组编号为0；1-499为系统预留编号；用户手动创建的组编号从500开始包括500 * /etc/gshadow 存储当前系统中用户组的密码信息 -Group: * : 123 :abc,def,xyz -组名称： 组密码 ： 组管理者 ：组中用户名列表 说明：组密码 为* 或 ！说明密码为空 * /etc/passwd 存储当前系统中所有用户的信息 -user : x : 123 : 456 : xxxxxxxxxx : /home/user : /bin/bash -用户名：密码占位符 ：用户编号：用户组编号：用户注释信息 ：用户主目录 ：shell类型 说明：root用户编号为0 * /etc/shadow 存储当前系统中所有用户密码的信息 -user : x ::::: -用户名：密码(单向加密) ：：：：：： 用户和用户组的基本命令groupadd group1 #添加用户组group1 groupmod -n group2 group1 #将组名由group1修改为group2 groupmod -g 668 group2 #将用户组group2的编号修改为668 groupadd -g 888 group3 #创建用户组group3，并指定组编号为888 groupdel group2 #删除用户组group2，要先删除组内用户 useradd -g group1 alvin #创建用户alvin，并分配用户组为group1 useradd -g group1 alex #创建用户alex，并分配用户组为group1 useradd -d /home/xxx mark #创建用户mark，并创建个人文件夹为home下的xxx alvin和alex没有指定，则默认在home下创建同名个人文件夹 注意：若创建的用户没有手动分配用户组，则自动创建同名用户组 新建用户属于该组 usermod -c thisisalvin alvin #修改用户alvin注释信息为thisisalvin usermod -l alvin alex #将用户名alex修改为alvin usermod -d /home/alvin alvin #修改用户alvin的个人文件夹路径为/home/alvin usermod -g group1 alvin #修改alvin所属用户组为group1 userdel alex #删除用户alex 不会删除个人文件夹 userdel -r alex #删除用户alex 同时删除个人文件夹 touch /etc/nologin #创建空文件，禁止除root外的用户登录服务器 用户和用户组进阶命令passwd -l alex #锁定账户alex passwd -u alex #解锁账户alex passwd -d alex #清除alex的登录密码 主要组和附属组： 用户可以同时属于多个组 -一个主要组 -多个附属组 gpasswd -a alex group2 #将alex添加到附属组group2 newgrp group2 #alex登录系统执行该命令，将当前组切换到附属组group2 gpasswd -d alex group2 #将alex用户从附属组group2中删除 useradd -g group1 -G group2,group3...... temp #在创建用户temp的同时指定主要组为group1，附属组为group2,group3...... gpasswd group1 #指定用户组密码 其它命令su username #切换用户 whoami #显示登陆用户名 id 用户名 #显示指定用户信息，包括用户编号、用户名、主要组编号，附属组列表 groups 用户名 #显示用户所在的所有组 chfn 用户名 #设置用户资料，依次输入用户资料 finger 用户名 #显示用户详细资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[『SPRING CLOUD』EUREKA]]></title>
      <url>%2F2016%2F09%2F09%2F%E3%80%8ESPRING-CLOUD%E3%80%8FEUREKA%2F</url>
      <content type="text"><![CDATA[Eureka 是 Netflix 开发的服务发现组件，基于REST服务。Spring Cloud 将其集成在其子项目 spring-cloud-netflix 中，实现 Spring Cloud 服务发现功能。目前最新版本 1.6.1。Eureka2.0 还在开发中。 Eureka Github:https://github.com/Netflix/eureka Region 和 Zone 的理解 Region 和 Zone 都是AWS中的概念。脱离AWS，我们可以简单的将Region理解为集群，Zone 理解为机房。这样就很清晰了，一个Eureka集群部署在 Zone1 和 Zone2 两个机房中。Spring Cloud Region 默认值是us-east-1 Eureka 架构 上图是官方给出的架构图，大致描述了Eureka集群工作模式。 Application Service 是服务提供者，Application Client 是服务消费者。Make Remote Call 简单的理解为 RESTFULL API 调用。us-east-1 为 Region, us-east-1* 为 Zone。 可以看出Eureka有两个组件， Eureka Server 和 Eureka Client。 Eureka Client 是一个 java 客户端。简化与 Eureka Server 的交互。Eureka Server 提供服务发现的能力，各个微服务启动的时候，通过 Eureka Client 向 Eureka Server 提交注册信息（网络信息），Eureka Server 存储客户端信息。微服务启动后，会周期性（默认30s）的向 Eureka Server 发送心跳续约租期，如果一定时间(默认90s)未收到微服务节点的心跳，服务端注销该微服务。每个 Eureka Server 同时也是 Eureka Client，多个Eureka Server之间通过复制的方式完成服务注册表的同步。Eureka Client 会缓存 Eureka Server 中的信息。即使所有的Eureka Server 节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。 实战Region 命名为 region1，在 region1 下定义 zone1 和 zone2 两个 zone， zone1 内有 peer1 和 peer2 两个 eureka 服务器，zone2 内有 peer3 一台服务器。 先来看服务器application.yml配置:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111---server: port: 1111spring: profiles: peer1 application: name: region-eureka# 安全认证的配置security: basic: enabled: true user: name: alvin # 用户名 password: alvin # 用户密码eureka: instance: hostname: peer1 preferIpAddress: false #使用IP注册 client: prefer-same-zone-eureka: true use-dns-for-fetching-service-urls: false #关闭dns获取服务 region: region1 availability-zones: region1: zone1,zone2# region2: zone3 serviceUrl: zone1: http://alvin:alvin@peer1:1111/eureka/,http://alvin:alvin@peer2:1112/eureka/ zone2: http://alvin:alvin@peer3:1113/eureka/ register-with-eureka: true #自身实例注册到eureka fetch-registry: true # 从eureka server 拉取最新服务列表 server: waitTimeInMsWhenSyncEmpty: 0 enable-self-preservation: false #设为false，关闭自我保护# eviction-interval-timer-in-ms: 清除无效节点的时间间隔 默认60*1000毫秒---server: port: 1112spring: profiles: peer2 application: name: region-eureka# 安全认证的配置security: basic: enabled: true user: name: alvin # 用户名 password: alvin # 用户密码eureka: instance: hostname: peer2 preferIpAddress: false #使用IP注册 client: prefer-same-zone-eureka: true use-dns-for-fetching-service-urls: false region: region1 availability-zones: region1: zone1,zone2# region2: zone3 serviceUrl: zone1: http://alvin:alvin@peer1:1111/eureka/,http://alvin:alvin@peer2:1112/eureka/ zone2: http://alvin:alvin@peer3:1113/eureka/ register-with-eureka: true fetch-registry: true server: waitTimeInMsWhenSyncEmpty: 0 enable-self-preservation: false---server: port: 1113spring: profiles: peer3 application: name: region-eureka# 安全认证的配置security: basic: enabled: true user: name: alvin # 用户名 password: alvin # 用户密码eureka: instance: hostname: peer3 preferIpAddress: false #使用IP注册 client: prefer-same-zone-eureka: true use-dns-for-fetching-service-urls: false region: region1 availability-zones: region1: zone1,zone2# region2: zone3 serviceUrl: zone1: http://alvin:alvin@peer1:1111/eureka/,http://alvin:alvin@peer2:1112/eureka/ zone2: http://alvin:alvin@peer3:1113/eureka/ register-with-eureka: true fetch-registry: true server: waitTimeInMsWhenSyncEmpty: 0 enable-self-preservation: false--- 顺序启动三台服务：12345java -jar demo-eureka-peer1-1.0-SNAPSHOT.jar --spring.profiles.active=peer1 &amp;java -jar demo-eureka-peer1-1.0-SNAPSHOT.jar --spring.profiles.active=peer2 &amp;java -jar demo-eureka-peer1-1.0-SNAPSHOT.jar --spring.profiles.active=peer3 &amp; 注意事项：三个服务 spring.application.name 要设置成一样的，同时 register-with-eureka 设置为 true 。否则 eureka 服务在 General Info 中显示 unavailable-replicas 。正确显示如下图： 客户端application.properties 配置：123456789spring.application.name=user-serviceserver.port=2221management.context-path=/alvineureka.client.region=region1eureka.client.availability-zones.region1=zone2eureka.client.service-url.zone2=http://alvin:alvin@peer3:1113/eureka/#eureka.client.serviceUrl.defaultZone=http://localhost:1113/eureka/eureka.instance.statusPageUrlPath=$&#123;management.context-path&#125;/infoeureka.instance.healthCheckUrlPath=$&#123;management.context-path&#125;/health 看一下其中一台eureka server，访问http://peer1:1111 ，由于设置了安全认证，需要输入账号(alvin)和密码(alvin)，显示如下： 注意到 eureka.client.use-dns-for-fetching-service-urls的设置为 false ，我没通过 service url 获取服务，其实还有更优雅的方式， 通过 eureka dns 域名获取服务。还没有时间研究，待研究过后再来补全，当然欢迎实践过的朋友指点一下。]]></content>
    </entry>

    
  
  
</search>
